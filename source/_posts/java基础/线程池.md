---
title: 线程池
date: 2019-04-04 10:14:13
category: java基础
tags: [线程池, ThreadPoolExecutor, ScheduledThreadPoolExecutor, ForkJoinPool]
---

# 线程池
为什么要用线程池？
线程的创建，销毁比较消耗性能，如果短时间内大量小任务仍然使用这种创建线程->执行任务->销毁线程模式，这样线程的效率比较低（每个任务都需要创建线程与销毁线程）。如果把线程给池化，一个线程处理完一个任务可以接着处理下一个任务，这样大大提高了线程的利用率。
<!--more-->

# 线程池的创建
阿里巴巴规范手册建议不要用Executors工具类来创建线程池，直接使用ThreadPoolExecutor构造方法来创建，这样使用者比较清楚线程池的一些参数。这里我并非说阿里文档的不好，如果你比较熟悉Executors源码，直接使用Executors工厂类的方法未尝不可。
下面我列举Executors一些常用的线程创建方法

```java
//创建一个固定线程数的线程池，队列无界
 public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}

 //创建一个线程的线程池，队列无界
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}

//创建一个无数量限制可伸缩的线程池
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
} 

//创建指定线程数量可计划执行任务的线程池
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}

//创建一个线程数量的可计划执行任务的线程池
public static ScheduledExecutorService newSingleThreadScheduledExecutor() {
    return new DelegatedScheduledExecutorService
        (new ScheduledThreadPoolExecutor(1));
}

//创建一个足够线程数量来支持指定并行级别的线程池。（线程数量可以动态伸缩）
public static ExecutorService newWorkStealingPool(int parallelism) {
    return new ForkJoinPool
        (parallelism,
         ForkJoinPool.defaultForkJoinWorkerThreadFactory,
         null, true);
}

//创建一个WorkStealingPool（并行级别指定为当前java虚拟机可用核心数）
public static ExecutorService newWorkStealingPool() {
    return new ForkJoinPool
        (Runtime.getRuntime().availableProcessors(),
         ForkJoinPool.defaultForkJoinWorkerThreadFactory,
         null, true);
}

```

从上面的方法实现，可以看到主要是用到了ThreadPoolExecutor、ScheduledThreadPoolExecutor和ForkJoinPool这三个类
查看类继承图：
![类图](I2ETEZ$B41BXPHHCXDG.png)

我们重点来看着三个类

# ThreadPoolExecutor
ThreadPoolExecutor是学习线程池的重点类，他继承了AbstractExecutorService抽象类（实现了ExecutorService接口）。我们先看看他的构造方法

## 构造器
```java
// Public constructors and methods
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }

    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             threadFactory, defaultHandler);
    }

    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              RejectedExecutionHandler handler) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), handler);
    }

    /**
     * Creates a new {@code ThreadPoolExecutor} with the given initial
     * parameters.
     *
     * @param corePoolSize the number of threads to keep in the pool, even
     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
     * @param maximumPoolSize the maximum number of threads to allow in the
     *        pool
     * @param keepAliveTime when the number of threads is greater than
     *        the core, this is the maximum time that excess idle threads
     *        will wait for new tasks before terminating.
     * @param unit the time unit for the {@code keepAliveTime} argument
     * @param workQueue the queue to use for holding tasks before they are
     *        executed.  This queue will hold only the {@code Runnable}
     *        tasks submitted by the {@code execute} method.
     * @param threadFactory the factory to use when the executor
     *        creates a new thread
     * @param handler the handler to use when execution is blocked
     *        because the thread bounds and queue capacities are reached
     * @throws IllegalArgumentException if one of the following holds:<br>
     *         {@code corePoolSize < 0}<br>
     *         {@code keepAliveTime < 0}<br>
     *         {@code maximumPoolSize <= 0}<br>
     *         {@code maximumPoolSize < corePoolSize}
     * @throws NullPointerException if {@code workQueue}
     *         or {@code threadFactory} or {@code handler} is null
     */
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```

我们可以看到这几个构造方法，最终都是调用最多参数的那个构造方法，我们先来看看这些参数的含义
### corePoolSize：核心池的大小。
* 核心池中的线程会一直保存在线程池中(即使线程空闲)，除非调用allowCoreThreadTimeOut方法允许核心线程在空闲后一定时间内销毁，该时间由构造方法中的keepAliveTime和unit参数指定；
* 在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这两个方法的名字就可以看出，是“预创建线程”的意思，即在没有任务到来之前就创建corePoolSize个线程(prestartAllCoreThreads)或者一个线程(prestartCoreThread)；
### maximumPoolSize：线程池允许的最大线程数。这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程。
* 默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把新加入的任务放到缓存队列当中，缓存队列由构造方法中的workQueue参数指定，如果入队失败(队列已满)则尝试创建临时线程，但临时线程和核心线程的总数不能超过maximumPoolSize，当线程总数达到maximumPoolSize后会拒绝新任务；所以有两种方式可以让任务绝不被拒绝：
① 将maximumPoolSize设置为Integer.MAX_VALUE(线程数不可能达到这个值)，CachedThreadPool就是这么做的；
② 使用无限容量的阻塞队列(比如LinkedBlockingQueue)，所有处理不过来的任务全部排队去，FixedThreadPool就是这么做的。
### keepAliveTime：
* 表示线程没有任务执行时最多保持多久时间会终止。
默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用——当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会被销毁，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(true)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；
### unit：
* 参数keepAliveTime的时间单位，有7种取值，在TimeUnit枚举类中有7种枚举值：
* 并发库中所有时间表示方法都是以TimeUnit枚举类作为单位
### workQueue：
* 一个阻塞队列(BlockingQueue接口的实现类)，用来存储等待执行的任务，一般来说，这里的阻塞队列有以下几种选择：
```
ArrayBlockingQueue    // 数组实现的阻塞队列，数组不支持自动扩容。所以当阻塞队列已满
                      // 线程池会根据handler参数中指定的拒绝任务的策略决定如何处理后面加入的任务

LinkedBlockingQueue   // 链表实现的阻塞队列，默认容量Integer.MAX_VALUE(不限容)，
                      // 当然也可以通过构造方法限制容量

SynchronousQueue      // 零容量的同步阻塞队列，添加任务直到有线程接受该任务才返回
                      // 用于实现生产者与消费者的同步，所以被叫做同步队列

PriorityBlockingQueue // 二叉堆实现的优先级阻塞队列

DelayQueue          // 延时阻塞队列，该队列中的元素需要实现Delayed接口
                    // 底层使用PriorityQueue的二叉堆对Delayed元素排序
                    // ScheduledThreadPoolExecutor底层就用了DelayQueue的变体"DelayWorkQueue"
                    // 队列中所有的任务都会封装成ScheduledFutureTask对象(该类已实现Delayed接口)
```

### threadFactory：
* 线程工厂，主要用来创建线程；默认情况都会使用Executors工具类中定义的默认工厂类DefaultThreadFactory。可以实现ThreadFactory接口来自己控制创建线程池的过程(比如设置创建线程的名字、优先级或者是否为Deamon守护线程)

### handler：
* 表示当拒绝处理任务时的策略，有以下四种取值(默认为AbortPolicy)：

```
ThreadPoolExecutor.AbortPolicy: 丢弃任务并抛出RejectedExecutionException异常。
ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务
可通过实现RejectedExecutionHandler接口来自定义任务拒绝后的处理策略
```

## 线程池的状态
线程池状态控制ctl，是一个AtomicInteger类型，他分成两段来表示workerCount（有效的线程数量,低29位）和runState（线程池的运行状态，高三位）
### runState 有如下几种

```shell
RUNNING: 接收新任务并且处理队列中的任务
STOP：   不接收新任务，不处理队列的任务，并且中断正在处理的任务
TIDYING: 所有任务已终止，workerCount等于0，将会执行terminated()勾子方法
TERMINATED：terminated()方法执行完成
```

#### 具体源码如下：

```java
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
private static final int COUNT_BITS = Integer.SIZE - 3;  	 //workerCount的位数 29
private static final int CAPACITY   = (1 << COUNT_BITS) - 1; //workerCount的容量，也就是workerCount的最大值, 00011111 11111111 11111111 11111111 

// runState is stored in the high-order bits 
private static final int RUNNING    = -1 << COUNT_BITS;  //11100000 00000000 00000000 00000000
private static final int SHUTDOWN   =  0 << COUNT_BITS;  //00000000 00000000 00000000 00000000
private static final int STOP       =  1 << COUNT_BITS;  //00100000 00000000 00000000 00000000
private static final int TIDYING    =  2 << COUNT_BITS;  //01000000 00000000 00000000 00000000
private static final int TERMINATED =  3 << COUNT_BITS;  //01100000 00000000 00000000 00000000

// Packing and unpacking ctl
private static int runStateOf(int c)     { return c & ~CAPACITY; }
private static int workerCountOf(int c)  { return c & CAPACITY; }
private static int ctlOf(int rs, int wc) { return rs | wc; }

```

### runState状态转换的过程
文档有如下的解释，我把他画成图
```
The runState monotonically increases over
time, but need not hit each state. The transitions are:
RUNNING -> SHUTDOWN
   On invocation of shutdown(), perhaps implicitly in finalize()
(RUNNING or SHUTDOWN) -> STOP
   On invocation of shutdownNow()
SHUTDOWN -> TIDYING
   When both queue and pool are empty
STOP -> TIDYING
   When pool is empty
TIDYING -> TERMINATED
   When the terminated() hook method has completed
```
![状态转换图](5NTAN13XPY0$~X_CSBM1.png)
 
可以看到改变状态的两个方法：shutdown方法则进去shutdown状态，shutdownNow则进去stop状态

```
	/**
     * Initiates an orderly shutdown in which previously submitted
     * tasks are executed, but no new tasks will be accepted.
     * Invocation has no additional effect if already shut down.
     *
     * <p>This method does not wait for previously submitted tasks to
     * complete execution.  Use {@link #awaitTermination awaitTermination}
     * to do that.
     *
     * @throws SecurityException {@inheritDoc}
     */
    public void shutdown() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            checkShutdownAccess();
            advanceRunState(SHUTDOWN);  //置为SHUTDOWN状态
            interruptIdleWorkers();     //中断空闲线程
            onShutdown(); // hook for ScheduledThreadPoolExecutor
        } finally {
            mainLock.unlock();
        }
        tryTerminate();
    }

    /**
     * Attempts to stop all actively executing tasks, halts the
     * processing of waiting tasks, and returns a list of the tasks
     * that were awaiting execution. These tasks are drained (removed)
     * from the task queue upon return from this method.
     *
     * <p>This method does not wait for actively executing tasks to
     * terminate.  Use {@link #awaitTermination awaitTermination} to
     * do that.
     *
     * <p>There are no guarantees beyond best-effort attempts to stop
     * processing actively executing tasks.  This implementation
     * cancels tasks via {@link Thread#interrupt}, so any task that
     * fails to respond to interrupts may never terminate.
     *
     * @throws SecurityException {@inheritDoc}
     */
    public List<Runnable> shutdownNow() {
        List<Runnable> tasks;
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            checkShutdownAccess();
            advanceRunState(STOP); //置为STOP状态
            interruptWorkers();    //中断所有线程
            tasks = drainQueue();  //把队列的任务清空，返回任务列表
        } finally {
            mainLock.unlock();
        }
        tryTerminate();
        return tasks;
    }
```

另外，还有一些状态查询的方法

```
    public boolean isShutdown() {
        return ! isRunning(ctl.get());
    }
 
   public boolean isTerminating() {
         int c = ctl.get();
         return ! isRunning(c) && runStateLessThan(c, TERMINATED);
   }
        
    public boolean isTerminated() {
        return runStateAtLeast(ctl.get(), TERMINATED);
    }
        
```

## 任务的提交
任务提交主要有三种方式：
execute(Runnable command)：定义在Executor接口中
submit的三个重载方法：定义在ExecutorService接口中
invoke(invokeAll,invokeAny)提交方式：定义在ExecutorService接口中

### execute方式提交
```java
     /**
     * 在未来某个时刻执行提交的任务。
     * 任务可能会被新开的线程或者线程池的线程执行
     * 如果任务不能提交，是因为线程池被关闭或者线程池队列已满，
     * 提交的任务被当前的{@code RejectedExecutionHandler}处理
     *
     * @param command the task to execute
     * @throws RejectedExecutionException at discretion of
     *         {@code RejectedExecutionHandler}, if the task
     *         cannot be accepted for execution
     * @throws NullPointerException if {@code command} is null
     */
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
       
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            //如果核心线程数未满，则创建核心线程数并将任务交给先线程处理（即使有空闲线程）
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        //再往下走，说明核心线程数已满
        
        if (isRunning(c) && workQueue.offer(command)) {
             //如果线程池仍是RUNNING状态，将任务加入工作队列
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                //如果线程不是RUNNING状态，将任务回滚移除工作队列并拒绝任务
                reject(command);
            else if (workerCountOf(recheck) == 0)
                //该情况用于核心线程数（corePoolSize）为0
                //或者核心线程数超时（allowCoreThreadTimeOut）的时候
                addWorker(null, false);
        }
        //入队失败则尝试创建普通临时线程（非核心线程）
        else if (!addWorker(command, false))
            //如果仍然无法创建线程，可以断定队列已满或者线程池已经SHUTDOWN，这时候走拒绝任务策略
            reject(command);
    }

```

#### 从源码可以得知以下执行流程：
* 如果正在运行的线程数小于corePoolSize, 则创建一个新的线程来执行，而不是任务排队
* 如果已有corePoolSize或者更多线程在运行，则优先任务排队，而不会新增线程。（这里要注意：任务成功入队仍要再次检查是否新增线程,因为上一次检查后线程可能就死了或者进入此方法线程池已经被SHUTDOWN，所以需要再次检查状态，如果有必要回滚队列，如果没有线程则启动新的线程）
* 如果任务请求不能排队，尝试新增一个非核心线程来执行，需要保证线程总数量不能大于maximumPoolSize,如果不能创建新的线程任务，则拒绝任务

> 如果我们调用preStartAllCoreThreads方法，预先把所有核心线程创建完成，并且allCoreThreadTimeOut不允许核心线程超时,这样workerCountOf(c) < corePoolSize这个条件永远不会成立
> workQueue.offer(command)，offer方法不会阻塞，如果入队成功会立即返回true否则返回false。入队成功与否取决于workQueue的性质。比如：①单链表实现的LinkedBlockingQueue默认容量为Integer.MAX_VALUE(等价于无限容量)，所以此时该方法不会返回false也不会创建临时线程(都去排队去了)，当然如果创建LinkedBlockingQueue时指定了capacity，offer方法就可能返回false，但我们一般不会这么干；②而数组实现的ArrayBlockingQueue不允许扩容，所以队列已满则会返回false进入尝试创建临时线程，如果总线程数不超过maximumPoolSize则能创建临时线程，但会导致后来的任务没排队反而能得到执行(不公平)，如果超出maximumPoolSize创建临时线程失败则会拒绝任务，两种情况都不好，所以ArrayBlockingQueue用的不是很多；③使用小顶堆实现的PriorityBlockingQueue会根据任务的优先级来选择执行顺序；④使用没有容量的同步队列SynchronousQueue，如果没有空闲线程接收任务会立即返回false，所以大部分情况会创建新的临时线程。
> workerCountOf(recheck) == 0：这句判断间接表示核心线程数为0的情况，核心线程数为0只会发生在两种条件下：①线程池本身已经指定核心数为0(构造方法指定或setCorePoolSize方法指定)，②调用allowCoreThreadTimeOut方法允许核心线程超时导致核心线程数位0。

### submit方式提交
submit方法的实现源码在ThreadPoolExecutor的基类AbstractExecutorService中
```java
    /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     */
    public Future<?> submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<Void> ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }

    /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     */
    public <T> Future<T> submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task, result);
        execute(ftask);
        return ftask;
    }

    /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     */
    public <T> Future<T> submit(Callable<T> task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }

```
submit最终都会调用execute方法去执行任务，区别在于submit方法返回一个FutureTask对象。对于FutureTask,这里不做深入讨论。

### invoke方式提交
invoke方法的实现源码在ThreadPoolExecutor的基类AbstractExecutorService中
```java
    /**
     * the main mechanics of invokeAny.
     */
    private <T> T doInvokeAny(Collection<? extends Callable<T>> tasks,
                              boolean timed, long nanos)
        throws InterruptedException, ExecutionException, TimeoutException {
        if (tasks == null)
            throw new NullPointerException();
        int ntasks = tasks.size();
        if (ntasks == 0)
            throw new IllegalArgumentException();
        ArrayList<Future<T>> futures = new ArrayList<Future<T>>(ntasks);
        ExecutorCompletionService<T> ecs =
            new ExecutorCompletionService<T>(this);

        // For efficiency, especially in executors with limited
        // parallelism, check to see if previously submitted tasks are
        // done before submitting more of them. This interleaving
        // plus the exception mechanics account for messiness of main
        // loop.

        try {
            // Record exceptions so that if we fail to obtain any
            // result, we can throw the last exception we got.
            ExecutionException ee = null;
            final long deadline = timed ? System.nanoTime() + nanos : 0L;
            Iterator<? extends Callable<T>> it = tasks.iterator();

            // Start one task for sure; the rest incrementally
            futures.add(ecs.submit(it.next()));
            --ntasks;
            int active = 1;

            for (;;) {
                Future<T> f = ecs.poll();
                if (f == null) {
                    if (ntasks > 0) {
                        --ntasks;
                        futures.add(ecs.submit(it.next()));
                        ++active;
                    }
                    else if (active == 0)
                        break;
                    else if (timed) {
                        f = ecs.poll(nanos, TimeUnit.NANOSECONDS);
                        if (f == null)
                            throw new TimeoutException();
                        nanos = deadline - System.nanoTime();
                    }
                    else
                        f = ecs.take();
                }
                if (f != null) {
                    --active;
                    try {
                        return f.get();
                    } catch (ExecutionException eex) {
                        ee = eex;
                    } catch (RuntimeException rex) {
                        ee = new ExecutionException(rex);
                    }
                }
            }

            if (ee == null)
                ee = new ExecutionException();
            throw ee;

        } finally {
            for (int i = 0, size = futures.size(); i < size; i++)
                futures.get(i).cancel(true);
        }
    }

    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)
        throws InterruptedException, ExecutionException {
        try {
            return doInvokeAny(tasks, false, 0);
        } catch (TimeoutException cannotHappen) {
            assert false;
            return null;
        }
    }

    public <T> T invokeAny(Collection<? extends Callable<T>> tasks,
                           long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException {
        return doInvokeAny(tasks, true, unit.toNanos(timeout));
    }

    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
        throws InterruptedException {
        if (tasks == null)
            throw new NullPointerException();
        ArrayList<Future<T>> futures = new ArrayList<Future<T>>(tasks.size());
        boolean done = false;
        try {
            for (Callable<T> t : tasks) {
                RunnableFuture<T> f = newTaskFor(t);
                futures.add(f);
                execute(f);
            }
            for (int i = 0, size = futures.size(); i < size; i++) {
                Future<T> f = futures.get(i);
                if (!f.isDone()) {
                    try {
                        f.get();
                    } catch (CancellationException ignore) {
                    } catch (ExecutionException ignore) {
                    }
                }
            }
            done = true;
            return futures;
        } finally {
            if (!done)
                for (int i = 0, size = futures.size(); i < size; i++)
                    futures.get(i).cancel(true);
        }
    }

    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                         long timeout, TimeUnit unit)
        throws InterruptedException {
        if (tasks == null)
            throw new NullPointerException();
        long nanos = unit.toNanos(timeout);
        ArrayList<Future<T>> futures = new ArrayList<Future<T>>(tasks.size());
        boolean done = false;
        try {
            for (Callable<T> t : tasks)
                futures.add(newTaskFor(t));

            final long deadline = System.nanoTime() + nanos;
            final int size = futures.size();

            // Interleave time checks and calls to execute in case
            // executor doesn't have any/much parallelism.
            for (int i = 0; i < size; i++) {
                execute((Runnable)futures.get(i));
                nanos = deadline - System.nanoTime();
                if (nanos <= 0L)
                    //如果超时，则直接返回结果
                    return futures;
            }

            //循环等待执行结果
            for (int i = 0; i < size; i++) {
                Future<T> f = futures.get(i); 
                if (!f.isDone()) {
                    //如果未完成，判断是否超时，超时则立马返回结果
                    if (nanos <= 0L)
                        return futures;
                    try {
                        //超时等待结果
                        f.get(nanos, TimeUnit.NANOSECONDS);
                        // invokeAll把这个异常给忽略了。
                        // 之所以要忽略，是要让所有的任务都执行完
                        // 所以外部调用者仍需要调用get()方法触发这个异常。
                    } catch (CancellationException ignore) {
                    } catch (ExecutionException ignore) {
                    } catch (TimeoutException toe) {
                        //等待超时，直接返回
                        return futures;
                    }
                    //还有多少纳秒后超时
                    nanos = deadline - System.nanoTime();
                }
            }
            done = true;
            return futures;
        } finally {
            //如果没有完成，则取消全部任务
            if (!done)
                for (int i = 0, size = futures.size(); i < size; i++)
                    futures.get(i).cancel(true);
        }
    }

```

* invokeAny取得率先完成的任务的返回值，当第一个任务结束后，会调用cancel方法取消其它任务。
* invokeAll等所有任务执行完毕后，取得全部任务的结果值。
* invokeAll有个严重的问题是，任务执行后不会抛出任务执行的异常。调用方需要手动调用Future.get()方法触发异常，而且FutureTask的异常是被ExecutionException包裹过的，所以调用get方法的时候是无法捕获到内部抛出的异常类型，要么通过捕获ExecutionException异常拿到它内部包装的异常，要么直接捕获所有的Exception。
* ExecutorCompletionService实际只是维护了一个队列，然后将完成的任务往队列里放，这个实现主要是依赖FutureTask的一个钩子方法done。

## 线程的创建
在execute方法中，我们可以知道线程的创建是用addWorker方法，接下来，我们来看看这个方法的具体实现。
```java
     /**
     * Checks if a new worker can be added with respect to current
     * pool state and the given bound (either core or maximum). If so,
     * the worker count is adjusted accordingly, and, if possible, a
     * new worker is created and started, running firstTask as its
     * first task. This method returns false if the pool is stopped or
     * eligible to shut down. It also returns false if the thread
     * factory fails to create a thread when asked.  If the thread
     * creation fails, either due to the thread factory returning
     * null, or due to an exception (typically OutOfMemoryError in
     * Thread.start()), we roll back cleanly.
     *
     * @param firstTask the task the new thread should run first (or
     * null if none). Workers are created with an initial first task
     * (in method execute()) to bypass queuing when there are fewer
     * than corePoolSize threads (in which case we always start one),
     * or when the queue is full (in which case we must bypass queue).
     * Initially idle threads are usually created via
     * prestartCoreThread or to replace other dying workers.
     *
     * @param core if true use corePoolSize as bound, else
     * maximumPoolSize. (A boolean indicator is used here rather than a
     * value to ensure reads of fresh values after checking other pool
     * state).
     * @return true if successful
     */
    private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (;;) {
            //获取线程池状态
            int c = ctl.get();
            int rs = runStateOf(c);

            //线程池已经SHUTDOWN，不接受任务
            if (rs >= SHUTDOWN &&
                ! (rs == SHUTDOWN &&
                   firstTask == null &&
                   ! workQueue.isEmpty()))
                return false;

            for (;;) {
                //获取当前线程池的工作线程数
                int wc = workerCountOf(c);
                if (wc >= CAPACITY || //超过最大线程数量
                    wc >= (core ? corePoolSize : maximumPoolSize)) //创建核心线程数,是否超过核心线程数（corePoolSize）；创建普通线程数，是否超过最大可允许线程数（maximumPoolSize）
                    // 拒绝
                    return false;
                // CAS 线程数，成功则跳出retry循环
                if (compareAndIncrementWorkerCount(c)) 
                    break retry;
                
                // cas失败，重新读取ctl，如果线程数改变，继续重试
                c = ctl.get();  // 重新读取ctl
                if (runStateOf(c) != rs)
                    continue retry;
            }
        }

        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            //创建Worker内部类对象，内部有一个Thread对象
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int rs = runStateOf(ctl.get());

                    if (rs < SHUTDOWN ||
                        (rs == SHUTDOWN && firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        // 将worker加入workers队列
                        workers.add(w);
                        int s = workers.size();
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) {
                    //成功加入队列，启动线程
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                //线程没成功启动，调用addWorkerFailed处理方法
                addWorkerFailed(w);
        }
        return workerStarted;
    }
    
        /**
         * Rolls back the worker thread creation.
         * - removes worker from workers, if present
         * - decrements worker count
         * - rechecks for termination, in case the existence of this
         *   worker was holding up termination
         */
        private void addWorkerFailed(Worker w) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                if (w != null)
                    workers.remove(w);  //从workers队列移除worker
                decrementWorkerCount(); //worker count 减 1
                tryTerminate();         //检查线程池是否触发terminated状态
            } finally {
                mainLock.unlock();
            }
        }

```

## 线程如何执行
上面中，我们知道创建线程是创建了一个Worker内部类，并且调用他的start方法，我们来揪下Worder类
```java
/**
     * Class Worker mainly maintains interrupt control state for
     * threads running tasks, along with other minor bookkeeping.
     * This class opportunistically extends AbstractQueuedSynchronizer
     * to simplify acquiring and releasing a lock surrounding each
     * task execution.  This protects against interrupts that are
     * intended to wake up a worker thread waiting for a task from
     * instead interrupting a task being run.  We implement a simple
     * non-reentrant mutual exclusion lock rather than use
     * ReentrantLock because we do not want worker tasks to be able to
     * reacquire the lock when they invoke pool control methods like
     * setCorePoolSize.  Additionally, to suppress interrupts until
     * the thread actually starts running tasks, we initialize lock
     * state to a negative value, and clear it upon start (in
     * runWorker).
     */
    private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
    {
        /**
         * This class will never be serialized, but we provide a
         * serialVersionUID to suppress a javac warning.
         */
        private static final long serialVersionUID = 6138294804551838833L;

        /** Thread this worker is running in.  Null if factory fails. */
        final Thread thread;
        /** Initial task to run.  Possibly null. */
        Runnable firstTask;
        /** Per-thread task counter */
        volatile long completedTasks;

        /**
         * Creates with given first task and thread from ThreadFactory.
         * @param firstTask the first task (null if none)
         */
        Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }

        /** Delegates main run loop to outer runWorker  */
        public void run() {
            runWorker(this);
        }

        // Lock methods
        //
        // The value 0 represents the unlocked state.
        // The value 1 represents the locked state.

        protected boolean isHeldExclusively() {
            return getState() != 0;
        }

        protected boolean tryAcquire(int unused) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        protected boolean tryRelease(int unused) {
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }

        public void lock()        { acquire(1); }
        public boolean tryLock()  { return tryAcquire(1); }
        public void unlock()      { release(1); }
        public boolean isLocked() { return isHeldExclusively(); }

        void interruptIfStarted() {
            Thread t;
            if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {
                try {
                    t.interrupt();
                } catch (SecurityException ignore) {
                }
            }
        }
    }

```
可以到Worker实现了Runnable接口，并且继承了同步队列接口（AbstractQueuedSynchronizer），我们看看他具体实现的run方法。

ThreadPoolExecutor.runWorker方法
```java
     /**
     * Main worker run loop.  Repeatedly gets tasks from queue and
     * executes them, while coping with a number of issues:
     *
     * 1. We may start out with an initial task, in which case we
     * don't need to get the first one. Otherwise, as long as pool is
     * running, we get tasks from getTask. If it returns null then the
     * worker exits due to changed pool state or configuration
     * parameters.  Other exits result from exception throws in
     * external code, in which case completedAbruptly holds, which
     * usually leads processWorkerExit to replace this thread.
     *
     * 2. Before running any task, the lock is acquired to prevent
     * other pool interrupts while the task is executing, and then we
     * ensure that unless pool is stopping, this thread does not have
     * its interrupt set.
     *
     * 3. Each task run is preceded by a call to beforeExecute, which
     * might throw an exception, in which case we cause thread to die
     * (breaking loop with completedAbruptly true) without processing
     * the task.
     *
     * 4. Assuming beforeExecute completes normally, we run the task,
     * gathering any of its thrown exceptions to send to afterExecute.
     * We separately handle RuntimeException, Error (both of which the
     * specs guarantee that we trap) and arbitrary Throwables.
     * Because we cannot rethrow Throwables within Runnable.run, we
     * wrap them within Errors on the way out (to the thread's
     * UncaughtExceptionHandler).  Any thrown exception also
     * conservatively causes thread to die.
     *
     * 5. After task.run completes, we call afterExecute, which may
     * also throw an exception, which will also cause thread to
     * die. According to JLS Sec 14.20, this exception is the one that
     * will be in effect even if task.run throws.
     *
     * The net effect of the exception mechanics is that afterExecute
     * and the thread's UncaughtExceptionHandler have as accurate
     * information as we can provide about any problems encountered by
     * user code.
     *
     * @param w the worker
     */
    final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            while (task != null || (task = getTask()) != null) {
                //如果task不为空，并且队列不为空
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &&
                      runStateAtLeast(ctl.get(), STOP))) &&
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    //执行beforeExecute回调方法
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        //执行afterExecute回调方法
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++; //完成任务数量++
                    w.unlock();
                }
            }
            //任务都被执行成功，没有被中断
            completedAbruptly = false;
        } finally {
            //processWorkerExit回调方法
            processWorkerExit(w, completedAbruptly);
        }
    }
    
    /**
     * Performs blocking or timed wait for a task, depending on
     * current configuration settings, or returns null if this worker
     * must exit because of any of:
     * 1. There are more than maximumPoolSize workers (due to
     *    a call to setMaximumPoolSize).
     * 2. The pool is stopped.
     * 3. The pool is shutdown and the queue is empty.
     * 4. This worker timed out waiting for a task, and timed-out
     *    workers are subject to termination (that is,
     *    {@code allowCoreThreadTimeOut || workerCount > corePoolSize})
     *    both before and after the timed wait, and if the queue is
     *    non-empty, this worker is not the last thread in the pool.
     *
     * @return task, or null if the worker must exit, in which case
     *         workerCount is decremented
     */
    private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?

        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }

            int wc = workerCountOf(c);

            // Are workers subject to culling?
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

            if ((wc > maximumPoolSize || (timed && timedOut))
                && (wc > 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }

            try {
                //是否超时，否则一直阻塞在take方法
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }

```
## 扩展ThreadPoolExecutor的功能
ThreadPoolExecutor提供一下的一些勾子方法
```java
    /* Extension hooks */

    /**
     * Method invoked prior to executing the given Runnable in the
     * given thread.  This method is invoked by thread {@code t} that
     * will execute task {@code r}, and may be used to re-initialize
     * ThreadLocals, or to perform logging.
     *
     * <p>This implementation does nothing, but may be customized in
     * subclasses. Note: To properly nest multiple overridings, subclasses
     * should generally invoke {@code super.beforeExecute} at the end of
     * this method.
     *
     * @param t the thread that will run task {@code r}
     * @param r the task that will be executed
     */
    protected void beforeExecute(Thread t, Runnable r) { }

    /**
     * Method invoked upon completion of execution of the given Runnable.
     * This method is invoked by the thread that executed the task. If
     * non-null, the Throwable is the uncaught {@code RuntimeException}
     * or {@code Error} that caused execution to terminate abruptly.
     *
     * <p>This implementation does nothing, but may be customized in
     * subclasses. Note: To properly nest multiple overridings, subclasses
     * should generally invoke {@code super.afterExecute} at the
     * beginning of this method.
     *
     * <p><b>Note:</b> When actions are enclosed in tasks (such as
     * {@link FutureTask}) either explicitly or via methods such as
     * {@code submit}, these task objects catch and maintain
     * computational exceptions, and so they do not cause abrupt
     * termination, and the internal exceptions are <em>not</em>
     * passed to this method. If you would like to trap both kinds of
     * failures in this method, you can further probe for such cases,
     * as in this sample subclass that prints either the direct cause
     * or the underlying exception if a task has been aborted:
     *
     *  <pre> {@code
     * class ExtendedExecutor extends ThreadPoolExecutor {
     *   // ...
     *   protected void afterExecute(Runnable r, Throwable t) {
     *     super.afterExecute(r, t);
     *     if (t == null && r instanceof Future<?>) {
     *       try {
     *         Object result = ((Future<?>) r).get();
     *       } catch (CancellationException ce) {
     *           t = ce;
     *       } catch (ExecutionException ee) {
     *           t = ee.getCause();
     *       } catch (InterruptedException ie) {
     *           Thread.currentThread().interrupt(); // ignore/reset
     *       }
     *     }
     *     if (t != null)
     *       System.out.println(t);
     *   }
     * }}</pre>
     *
     * @param r the runnable that has completed
     * @param t the exception that caused termination, or null if
     * execution completed normally
     */
    protected void afterExecute(Runnable r, Throwable t) { }

    /**
     * Method invoked when the Executor has terminated.  Default
     * implementation does nothing. Note: To properly nest multiple
     * overridings, subclasses should generally invoke
     * {@code super.terminated} within this method.
     */
    protected void terminated() { }

```
官网文档对勾子方法的拓展demo
```java

class PausableThreadPoolExecutor extends ThreadPoolExecutor {
  private boolean isPaused;
  private ReentrantLock pauseLock = new ReentrantLock();
  private Condition unpaused = pauseLock.newCondition();

  public PausableThreadPoolExecutor(...) { super(...); }

  protected void beforeExecute(Thread t, Runnable r) {
    super.beforeExecute(t, r);
    pauseLock.lock();
    try {
      while (isPaused) unpaused.await();
    } catch (InterruptedException ie) {
      t.interrupt();
    } finally {
      pauseLock.unlock();
    }
  }

  public void pause() {
    pauseLock.lock();
    try {
      isPaused = true;
    } finally {
      pauseLock.unlock();
    }
  }

  public void resume() {
    pauseLock.lock();
    try {
      isPaused = false;
      unpaused.signalAll();
    } finally {
      pauseLock.unlock();
    }
  }
}

```

# ScheduledThreadPoolExecutor
ScheduledThreadPoolExecutor继承ThreadPoolExecutor类，并实现了ScheduledExecutorService接口。
我们来看下ScheduledExecutorService接口定义的三个方法
## ScheduledExecutorService接口
```java
    /**
     * 在给定的延时时间，执行Runnalbe(执行一次)
     */
    public ScheduledFuture<?> schedule(Runnable command,
                                       long delay, TimeUnit unit);

    /**
     * 在给定的延迟时间，执行Callable(执行一次)
     */
    public <V> ScheduledFuture<V> schedule(Callable<V> callable,
                                           long delay, TimeUnit unit);

    /**
     * 延迟initialDelay执行Runnable,然后以一定的时间period间隔执行,Runnable执行时间不能大于period
     */
    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,
                                                  long initialDelay,
                                                  long period,
                                                  TimeUnit unit);

    /**
     * 延迟initialDelay执行Runnable，然后每次执行Runnable后延迟delay再执行
     */
    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,
                                                     long initialDelay,
                                                     long delay,
                                                     TimeUnit unit);

```

## ScheduledThreadPoolExecutor构造方法
```java
    /**
     * Creates a new {@code ScheduledThreadPoolExecutor} with the
     * given core pool size.
     *
     * @param corePoolSize the number of threads to keep in the pool, even
     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
     * @throws IllegalArgumentException if {@code corePoolSize < 0}
     */
    public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
              new DelayedWorkQueue());
    }

    /**
     * Creates a new {@code ScheduledThreadPoolExecutor} with the
     * given initial parameters.
     *
     * @param corePoolSize the number of threads to keep in the pool, even
     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
     * @param threadFactory the factory to use when the executor
     *        creates a new thread
     * @throws IllegalArgumentException if {@code corePoolSize < 0}
     * @throws NullPointerException if {@code threadFactory} is null
     */
    public ScheduledThreadPoolExecutor(int corePoolSize,
                                       ThreadFactory threadFactory) {
        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
              new DelayedWorkQueue(), threadFactory);
    }

    /**
     * Creates a new ScheduledThreadPoolExecutor with the given
     * initial parameters.
     *
     * @param corePoolSize the number of threads to keep in the pool, even
     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
     * @param handler the handler to use when execution is blocked
     *        because the thread bounds and queue capacities are reached
     * @throws IllegalArgumentException if {@code corePoolSize < 0}
     * @throws NullPointerException if {@code handler} is null
     */
    public ScheduledThreadPoolExecutor(int corePoolSize,
                                       RejectedExecutionHandler handler) {
        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
              new DelayedWorkQueue(), handler);
    }

    /**
     * Creates a new ScheduledThreadPoolExecutor with the given
     * initial parameters.
     *
     * @param corePoolSize the number of threads to keep in the pool, even
     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
     * @param threadFactory the factory to use when the executor
     *        creates a new thread
     * @param handler the handler to use when execution is blocked
     *        because the thread bounds and queue capacities are reached
     * @throws IllegalArgumentException if {@code corePoolSize < 0}
     * @throws NullPointerException if {@code threadFactory} or
     *         {@code handler} is null
     */
    public ScheduledThreadPoolExecutor(int corePoolSize,
                                       ThreadFactory threadFactory,
                                       RejectedExecutionHandler handler) {
        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
              new DelayedWorkQueue(), threadFactory, handler);
    }

```
我们可以看到ScheduledThreadPoolExecutor的构造方法都是直接调用父类ThreadPoolExecutor的构造方法，唯一不同的是，BlockingQueue写死了DelayedWorkQueue（延迟队列）。该队列是ScheduledThreadPoolExecutor类的核心组件，后面详细介绍。这里没有向用户开放maximumPoolSize的设置，原因是DelayedWorkQueue中的元素在大于初始容量16时，会进行扩容，也就是说队列不会装满，maximumPoolSize参数即使设置了也不会生效。worker线程没有回收时间，因为不会触发回收操作。所以这里的线程存活时间都设置为0。

## 任务提交
也就是实现ScheduledExecutorService接口的四个方法，我们先来看schedule方法

```java
     /**
         * @throws RejectedExecutionException {@inheritDoc}
         * @throws NullPointerException       {@inheritDoc}
         */
        public ScheduledFuture<?> schedule(Runnable command,
                                           long delay,
                                           TimeUnit unit) {
            if (command == null || unit == null)
                throw new NullPointerException();
            RunnableScheduledFuture<?> t = decorateTask(command,
                new ScheduledFutureTask<Void>(command, null,
                                              triggerTime(delay, unit)));
            delayedExecute(t);
            return t;
        }
    
        /**
         * @throws RejectedExecutionException {@inheritDoc}
         * @throws NullPointerException       {@inheritDoc}
         */
        public <V> ScheduledFuture<V> schedule(Callable<V> callable,
                                               long delay,
                                               TimeUnit unit) {
            if (callable == null || unit == null)
                throw new NullPointerException();
            RunnableScheduledFuture<V> t = decorateTask(callable,
                new ScheduledFutureTask<V>(callable,
                                           triggerTime(delay, unit)));
            delayedExecute(t);
            return t;
        }

```

来重点看delayedExecute方法

```java
    /**
     * Main execution method for delayed or periodic tasks.  If pool
     * is shut down, rejects the task. Otherwise adds task to queue
     * and starts a thread, if necessary, to run it.  (We cannot
     * prestart the thread to run the task because the task (probably)
     * shouldn't be run yet.)  If the pool is shut down while the task
     * is being added, cancel and remove it if required by state and
     * run-after-shutdown parameters.
     *
     * @param task the task
     */
    private void delayedExecute(RunnableScheduledFuture<?> task) {
        //如果线程池关闭，拒绝任务
        if (isShutdown())
            reject(task);
        else {
            //直接加入队列
            super.getQueue().add(task);
            //如果线程池关闭并且不能在关闭状态启动，则移除任务，并取消任务
            if (isShutdown() &&
                !canRunInCurrentRunState(task.isPeriodic()) &&
                remove(task))
                task.cancel(false);
            else
                //这里是增加一个worker线程，避免提交的任务没有worker去执行
                //原因就是该类没有像ThreadPoolExecutor一样，woker满了才放入队列
                ensurePrestart();
        }
    }

```
这里的关键点其实就是super.getQueue().add(task)行代码，ScheduledThreadPoolExecutor类在内部自己实现了一个基于堆数据结构的延迟队列。add方法最终会落到offer方法中，一起看下：
```java
        public boolean offer(Runnable x) {
            if (x == null)
                throw new NullPointerException();
            RunnableScheduledFuture<?> e = (RunnableScheduledFuture<?>)x;
            final ReentrantLock lock = this.lock;
            lock.lock();
            try {
                //当前元素大于队列大小，进行扩容，（扩容0.5倍）
                int i = size;
                if (i >= queue.length)
                    grow();
                //元素个数+1
                size = i + 1;
                //如果原来队列为空，放在队列第一个，并且设置索引
                if (i == 0) {
                    queue[0] = e;
                    setIndex(e, 0);
                } else {
                    //把任务加入堆中，根据任务的执行时间进行堆排序，先执行的排在前面
                    siftUp(i, e);
                }
                
                //如果第一个元素刚好是刚加入的元素
                //这里有两种情况：1、队列为空的情况，2、排序后刚加入的元素刚好是第一个
                if (queue[0] == e) {
                    //这个变量起优化作用，后面说
                    leader = null;
                    //加入元素后唤醒worker线程
                    available.signal();
                }
            } finally {
                lock.unlock();
            }
            return true;
        }

```

通过上面的逻辑，我们把提交的任务成功加入到了延迟队列中，前面说了加入任务以后会开启一个woker线程，该线程的任务就是从延迟队列中不断取出任务执行。这些都是跟ThreadPoolExecutor相同的，我们看下从该延迟队列中获取元素的源码

```java
        public RunnableScheduledFuture<?> take() throws InterruptedException {
            final ReentrantLock lock = this.lock;
            lock.lockInterruptibly();
            try {
                for (;;) {
                    //取队列的第一个任务
                    RunnableScheduledFuture<?> first = queue[0];
                    if (first == null)
                        //如果没有任务，则等待
                        available.await();
                    else {
                        //获取任务延迟执行的时间
                        long delay = first.getDelay(NANOSECONDS);
                        //执行时间已到，执行出列操作
                        if (delay <= 0)
                            return finishPoll(first);
                        first = null; // don't retain ref while waiting
                        //表示任务已分配给其他线程，只需要等待唤醒即可
                        if (leader != null)
                            available.await();
                        else {
                            //否则用当前线程执行任务
                            Thread thisThread = Thread.currentThread();
                            leader = thisThread;
                            try {
                                //等待超时时间
                                available.awaitNanos(delay);
                            } finally {
                                if (leader == thisThread)
                                    leader = null;
                            }
                        }
                    }
                }
            } finally {
                //当前队列不为空，唤醒其他worker
                if (leader == null && queue[0] != null)
                    available.signal();
                lock.unlock();
            }
        }

```
> 这里为什么会加入一个leader变量来分配阻塞队列中的任务呢？原因是要减少不必要的时间等待。比如说现在队列中的第一个任务1分钟后执行，那么用户提交新的任务时会不断的加入woker线程，如果新提交的任务都排在队列后面，也就是说新的woker现在都会取出这第一个任务进行执行延迟时间的等待，当该任务到触发时间时，会唤醒很多woker线程，这显然是没有必要的。

当任务被woker线程取出以后，会执行run方法，由于此时任务已经被包装成了ScheduledFutureTask对象，那我们来看下该类的run方法：

```java
        /**
         * Overrides FutureTask version so as to reset/requeue if periodic.
         */
        public void run() {
            //是否周期性执行
            boolean periodic = isPeriodic();
            //当前线程池状态不可以执行任务，则取消任务
            if (!canRunInCurrentRunState(periodic))
                cancel(false);
            else if (!periodic)
                //非周期性执行，直接调用父类run方法
                ScheduledFutureTask.super.run();
            else if (ScheduledFutureTask.super.runAndReset()) {
                //周期性调用，执行后，设置下一次执行时间，并重新加入队列
                setNextRunTime();
                reExecutePeriodic(outerTask);
            }
        }

```
至此，已经走完scheduled方法


我们继续看剩下的另外两个方法（周期性执行任务）
```java
    /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     * @throws IllegalArgumentException   {@inheritDoc}
     */
    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,
                                                  long initialDelay,
                                                  long period,
                                                  TimeUnit unit) {
        if (command == null || unit == null)
            throw new NullPointerException();
        if (period <= 0)
            throw new IllegalArgumentException();
        ScheduledFutureTask<Void> sft =
            new ScheduledFutureTask<Void>(command,
                                          null,
                                          triggerTime(initialDelay, unit),
                                          unit.toNanos(period));
        RunnableScheduledFuture<Void> t = decorateTask(command, sft);
        sft.outerTask = t;
        delayedExecute(t);
        return t;
    }

    /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     * @throws IllegalArgumentException   {@inheritDoc}
     */
    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,
                                                     long initialDelay,
                                                     long delay,
                                                     TimeUnit unit) {
        if (command == null || unit == null)
            throw new NullPointerException();
        if (delay <= 0)
            throw new IllegalArgumentException();
        ScheduledFutureTask<Void> sft =
            new ScheduledFutureTask<Void>(command,
                                          null,
                                          triggerTime(initialDelay, unit),
                                          unit.toNanos(-delay));
        RunnableScheduledFuture<Void> t = decorateTask(command, sft);
        sft.outerTask = t;
        delayedExecute(t);
        return t;
    }

```
我们可以看到他们的区别在与构造方法一个是将delay参数以负数的形式传入给ScheduledFutureTask

我们看看周期性任务执行后重新计算下次任务执行时间setNextRunTime方法
```java
        /**
         * Sets the next time to run for a periodic task.
         */
        private void setNextRunTime() {
            long p = period;
            if (p > 0)
                time += p;
            else
                time = triggerTime(-p);
        }
        
    /**
     * Returns the trigger time of a delayed action.
     */
    long triggerTime(long delay) {
        return now() +
            ((delay < (Long.MAX_VALUE >> 1)) ? delay : overflowFree(delay));
    }

    /**
     * Constrains the values of all delays in the queue to be within
     * Long.MAX_VALUE of each other, to avoid overflow in compareTo.
     * This may occur if a task is eligible to be dequeued, but has
     * not yet been, while some other task is added with a delay of
     * Long.MAX_VALUE.
     */
    private long overflowFree(long delay) {
        Delayed head = (Delayed) super.getQueue().peek();
        if (head != null) {
            long headDelay = head.getDelay(NANOSECONDS);
            if (headDelay < 0 && (delay - headDelay < 0))
                delay = Long.MAX_VALUE + headDelay;
        }
        return delay;
    }        

```
可以看到当period>0(scheduleAtFixedRate方法)，就是开始执行那一刻的时间添加period时间，当period<0(scheduleWithFixedDelay方法)，在当前时间的基础上添加period时间

## 总结
* 与ThreadPoolExecutor不同，向ScheduledThreadPoolExecutor中提交任务的时候，任务被包装成ScheduledFutureTask对象加入延迟队列并启动一个woker线程。（包装了任务，并且自定义实现阻塞队列[堆算法实现]）
* 用户提交的任务加入延迟队列时，会按照执行时间进行排列，也就是说队列头的任务是需要最早执行的。而woker线程会从延迟队列中获取任务，如果已经到了任务的执行时间，则开始执行。否则阻塞等待剩余延迟时间后再尝试获取任务。
* 任务执行完成以后，如果该任务是一个需要周期性反复执行的任务，则计算好下次执行的时间后会重新加入到延迟队列中。


# ForkJoinPool(略)


