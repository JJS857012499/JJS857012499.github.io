---
title: 消息队列基础点
date: 2019-03-05 14:53:55
category: mq
tags: [mq, 基础，一致性，幂等]
---

# 消息队列应用的场景
1、业务解耦：消息队列要解决的最本质问题，实现设计的单一性原则，不耦合其他模块的业务。
2、最终一致性：用来处理延迟不那么敏感的“分布式事务”场景或者不重要的业务。
3、广播：下游有很多系统关心你的系统发出的通知的时候。
4、错峰和流控：上下游系统处理能力存在差距的时候，利用消息队列做一个通用的“漏斗”。在下游有能力处理的时候，再进行分发。
<!-- more -->

# 最终一致性的设计思路
1、主要是用“记录”和“补偿”的方式。
2、本地事务维护业务变化和通知消息，一起落地，然后RPC到达broker，在broker成功落地后，RPC返回成功，本地消息可以删除。否则本地消息一直靠定时任务轮询不断重发，这样就保证了消息可靠落地broker。
3、broker往consumer发送消息的过程类似，一直发送消息，直到consumer发送消费成功确认。
4、我们先不理会重复消息的问题，通过两次消息落地加补偿，下游是一定可以收到消息的。然后依赖状态机版本号等方式做判重，更新自己的业务，就实现了最终一致性。
5、如果出现消费方处理过慢消费不过来，要允许消费方主动ack error，并可以与broker约定下次投递的时间。
6、对于broker投递到consumer的消息，由于不确定丢失是在业务处理过程中还是消息发送丢失的情况下，有必要记录下投递的IP地址。决定重发之前询问这个IP，消息处理成功了吗？如果询问无果，再重发。
7、事务：本地事务，本地落地，补偿发送。本地事务做的，是业务落地和消息落地的事务，而不是业务落地和RPC成功的事务。消息只要成功落地，很大程度上就没有丢失的风险。

# 满足顺序消息的条件
1、允许消息丢失。
2、从发送方到服务方到接受者都是单点单线程。

# 如何鉴别消息重复，并幂等的处理重复消息
1、鉴别消息重复：利用存储系统的唯一键，给每个消息加上一个MessageId
2、幂等处理重复消息的方法： 
2.1、跟鉴别消息重复一样，利用MessageId，重复即不处理
2.2、版本号，每个消息都带一个版本号，只处理比当前存储版本号高的消息
2.3、状态机，跟业务耦合比较严重，根据具体业务类型判断

# 消息队列的两种模型push和pull的对比
1、push的缺点：慢消费。指broker给consumer推送一堆consumer无法处理的消息，consumer不是reject就是error，然后来回踢皮球。
2、pull的缺点：消息延迟与盲等。pull是消费方主动定时去拉去消息，由于消息的不确定性，所以会造成会多无用的请求。
RocketMQ的设计方案：长轮询，来平衡推拉模型各自的缺点。基本思路是:消费者如果尝试拉取失败，不是直接return,而是把连接挂在那里wait,服务端如果有新的消息到来，把连接notify起来。但海量的长连接block对系统的开销还是不容小觑的，还是要合理的评估时间间隔，给wait加一个时间上限。
