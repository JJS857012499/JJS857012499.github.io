---
title: 动态规划之背包问题
date: 2017-09-25 11:31:04
category: 算法
tags: [动态规划,背包问题]
---
## 定义一个背包对象
```java
package com.zhidian.bag;

/**
 * Created by 江俊升 on 2017/9/23.
 */
public class PackageItem {

    public String name;
    public Integer weight;
    public Integer value;

    public PackageItem(String name, Integer weight, Integer value) {
        this.name = name;
        this.weight = weight;
        this.value = value;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getWeight() {
        return weight;
    }

    public void setWeight(Integer weight) {
        this.weight = weight;
    }

    public Integer getValue() {
        return value;
    }

    public void setValue(Integer value) {
        this.value = value;
    }
}
```
## 核心代码
```java
package com.zhidian.bag;

import java.util.ArrayList;
import java.util.List;

/**
 *
 http://blog.csdn.net/mu399/article/details/7722810
 01背包的状态转换方程 f[i,j] = Max{ f[i-1,j-Wi]+Pi( j >= Wi ),  f[i-1,j] }
 f[i,j]表示在前i件物品中选择若干件放在承重为 j 的背包中，可以取得的最大价值。
 Pi表示第i件物品的价值。
 决策：为了背包中物品总价值最大化，第 i件物品应该放入背包中吗 ？

 * Created by 江俊升 on 2017/9/23.
 */
public class BagUtils {


    public List get01PackageAnswer(List<PackageItem> bagItems, int bagSize) {

        int[][] bagMatrix = new int[bagItems.size()][bagSize+1];
        int i;
        PackageItem item;
        for (i = 0; i < bagItems.size(); i++) {
            bagMatrix[0][i] = 0;
        }
        for (i = 1; i <= bagSize; i++) {
            for (int j = 0; j < bagItems.size(); j++) {
                item = bagItems.get(j);
                if (item.weight > i) {
                    //i背包转不下item
                    if (j == 0) {
                        bagMatrix[j][i] = 0;
                    } else {
                        bagMatrix[j][i] = bagMatrix[j - 1][i];
                    }
                } else {
                    //将item装入背包后的价值总和
                    int itemInBag;
                    if (j == 0) {
                        bagMatrix[j][i] = item.value;
                        continue;
                    } else {
                        itemInBag = bagMatrix[j - 1][i - item.weight] + item.value;
                    }
                    bagMatrix[j][i] = (bagMatrix[j - 1][i] > itemInBag ? bagMatrix[j - 1][i] : itemInBag);
                }
            }
        }
        //find answer
        List<String> answers = new ArrayList<>();
        int curSize = bagSize;
        for (i = bagItems.size() - 1; i >= 0; i--) {
            item = bagItems.get(i);
            if (curSize == 0)
                break;
            if (i == 0 && curSize > 0) {
                answers.add(item.name);
                break;
            }
            if (bagMatrix[i][curSize] - bagMatrix[i - 1][curSize - item.weight] == item.value) {
                answers.add(item.name);
                curSize -= item.weight;
            }
        }
        return answers;
    }

    /**
     * 题目描述：
     有编号分别为a,b,c,d,e的五件物品，它们的重量(w)分别是2,2,6,5,4，它们的价值(v)分别是6,3,5,4,6，现在给你个承重为10的背包，如何让背包里装入的物品具有最大的价值总和？

     n	w	v	1	2	3	4	5	6	7	8	9	10
     a	2	6	0	6	6	9	9	12	12	15	15	15
     b	2	3	0	3	3	6	6	9	9	9	10	11
     c	6	5	0	0	0	6	6	6	6	6	10	11
     d	5	4	0	0	0	6	6	6	6	6	10	10
     e	4	6	0	0	0	6	6	6	6	6	6	6

     只要你能通过找规律手工填写出上面这张表就算理解了01背包的动态规划算法。
     首先要明确这张表是至底向上，从左到右生成的。
     为了叙述方便，用e2单元格表示e行2列的单元格，这个单元格的意义是用来表示只有物品e时，有个承重为2的背包，那么这个背包的最大价值是0，因为e物品的重量是4，背包装不了。
     对于d2单元格，表示只有物品e，d时,承重为2的背包,所能装入的最大价值，仍然是0，因为物品e,d都不是这个背包能装的。
     同理，c2=0，b2=3,a2=6。
     对于承重为8的背包，a8=15,是怎么得出的呢？
     根据01背包的状态转换方程，需要考察两个值，

     一个是f[i-1,j],对于这个例子来说就是b8的值9，另一个是f[i-1,j-Wi]+Pi；

     在这里，

     f[i-1,j]表示我有一个承重为8的背包，当只有物品b,c,d,e四件可选时，这个背包能装入的最大价值
     f[i-1,j-Wi]表示我有一个承重为6的背包（等于当前背包承重减去物品a的重量），当只有物品b,c,d,e四件可选时，这个背包能装入的最大价值
     f[i-1,j-Wi]就是指单元格b6,值为9，Pi指的是a物品的价值，即6
     由于f[i-1,j-Wi]+Pi = 9 + 6 = 15 大于f[i-1,j] = 9，所以物品a应该放入承重为8的背包

     * @param args
     */
    public static void main(String[] args){

        String[] nameArr= new String[]{"a","b","c","d","e"};
        int[] weightArr = new int[]{2,2,6,5,4};
        int[] valueArr = new int[]{6,3,5,4,6};

        List bagItems = new ArrayList(nameArr.length);
        for(int i=0;i<nameArr.length;i++)
        {
            PackageItem bagItem = new PackageItem(nameArr[i],weightArr[i],valueArr[i]);
            bagItems.add(bagItem);
        }
        List packageAnswer = new BagUtils().get01PackageAnswer(bagItems, 10);
        System.out.println(packageAnswer);
    }
}
```
